"""slackwebapi.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

# ruff: noqa: E501
from slackwebapi.api_helper import APIHelper
from slackwebapi.models.purpose import Purpose
from slackwebapi.models.topic import Topic


class ChannelObject(object):
    """Implementation of the 'Channel Object' model.

    Attributes:
        accepted_user (str): The model property of type str.
        created (int): The model property of type int.
        creator (str): The model property of type str.
        id (str): The model property of type str.
        is_archived (bool): The model property of type bool.
        is_channel (bool): The model property of type bool.
        is_frozen (bool): The model property of type bool.
        is_general (bool): The model property of type bool.
        is_member (bool): The model property of type bool.
        is_moved (int): The model property of type int.
        is_mpim (bool): The model property of type bool.
        is_non_threadable (bool): The model property of type bool.
        is_org_shared (bool): The model property of type bool.
        is_pending_ext_shared (bool): The model property of type bool.
        is_private (bool): The model property of type bool.
        is_read_only (bool): The model property of type bool.
        is_shared (bool): The model property of type bool.
        is_thread_only (bool): The model property of type bool.
        last_read (str): The model property of type str.
        latest (Any): The model property of type Any.
        members (List[str]): The model property of type List[str].
        name (str): The model property of type str.
        name_normalized (str): The model property of type str.
        num_members (int): The model property of type int.
        pending_shared (List[str]): The model property of type List[str].
        previous_names (List[str]): The model property of type List[str].
        priority (float): The model property of type float.
        purpose (Purpose): The model property of type Purpose.
        topic (Topic): The model property of type Topic.
        unlinked (int): The model property of type int.
        unread_count (int): The model property of type int.
        unread_count_display (int): The model property of type int.
        additional_properties (Dict[str, Any]): The additional properties for the
            model.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "created": "created",
        "creator": "creator",
        "id": "id",
        "is_channel": "is_channel",
        "is_mpim": "is_mpim",
        "is_org_shared": "is_org_shared",
        "is_private": "is_private",
        "is_shared": "is_shared",
        "members": "members",
        "name": "name",
        "name_normalized": "name_normalized",
        "purpose": "purpose",
        "topic": "topic",
        "accepted_user": "accepted_user",
        "is_archived": "is_archived",
        "is_frozen": "is_frozen",
        "is_general": "is_general",
        "is_member": "is_member",
        "is_moved": "is_moved",
        "is_non_threadable": "is_non_threadable",
        "is_pending_ext_shared": "is_pending_ext_shared",
        "is_read_only": "is_read_only",
        "is_thread_only": "is_thread_only",
        "last_read": "last_read",
        "latest": "latest",
        "num_members": "num_members",
        "pending_shared": "pending_shared",
        "previous_names": "previous_names",
        "priority": "priority",
        "unlinked": "unlinked",
        "unread_count": "unread_count",
        "unread_count_display": "unread_count_display",
    }

    _optionals = [
        "accepted_user",
        "is_archived",
        "is_frozen",
        "is_general",
        "is_member",
        "is_moved",
        "is_non_threadable",
        "is_pending_ext_shared",
        "is_read_only",
        "is_thread_only",
        "last_read",
        "latest",
        "num_members",
        "pending_shared",
        "previous_names",
        "priority",
        "unlinked",
        "unread_count",
        "unread_count_display",
    ]

    def __init__(
        self,
        created=None,
        creator=None,
        id=None,
        is_channel=None,
        is_mpim=None,
        is_org_shared=None,
        is_private=None,
        is_shared=None,
        members=None,
        name=None,
        name_normalized=None,
        purpose=None,
        topic=None,
        accepted_user=APIHelper.SKIP,
        is_archived=APIHelper.SKIP,
        is_frozen=APIHelper.SKIP,
        is_general=APIHelper.SKIP,
        is_member=APIHelper.SKIP,
        is_moved=APIHelper.SKIP,
        is_non_threadable=APIHelper.SKIP,
        is_pending_ext_shared=APIHelper.SKIP,
        is_read_only=APIHelper.SKIP,
        is_thread_only=APIHelper.SKIP,
        last_read=APIHelper.SKIP,
        latest=APIHelper.SKIP,
        num_members=APIHelper.SKIP,
        pending_shared=APIHelper.SKIP,
        previous_names=APIHelper.SKIP,
        priority=APIHelper.SKIP,
        unlinked=APIHelper.SKIP,
        unread_count=APIHelper.SKIP,
        unread_count_display=APIHelper.SKIP,
        additional_properties=None):
        """Initialize a ChannelObject instance."""
        # Initialize members of the class
        if accepted_user is not APIHelper.SKIP:
            self.accepted_user = accepted_user
        self.created = created
        self.creator = creator
        self.id = id
        if is_archived is not APIHelper.SKIP:
            self.is_archived = is_archived
        self.is_channel = is_channel
        if is_frozen is not APIHelper.SKIP:
            self.is_frozen = is_frozen
        if is_general is not APIHelper.SKIP:
            self.is_general = is_general
        if is_member is not APIHelper.SKIP:
            self.is_member = is_member
        if is_moved is not APIHelper.SKIP:
            self.is_moved = is_moved
        self.is_mpim = is_mpim
        if is_non_threadable is not APIHelper.SKIP:
            self.is_non_threadable = is_non_threadable
        self.is_org_shared = is_org_shared
        if is_pending_ext_shared is not APIHelper.SKIP:
            self.is_pending_ext_shared = is_pending_ext_shared
        self.is_private = is_private
        if is_read_only is not APIHelper.SKIP:
            self.is_read_only = is_read_only
        self.is_shared = is_shared
        if is_thread_only is not APIHelper.SKIP:
            self.is_thread_only = is_thread_only
        if last_read is not APIHelper.SKIP:
            self.last_read = last_read
        if latest is not APIHelper.SKIP:
            self.latest = latest
        self.members = members
        self.name = name
        self.name_normalized = name_normalized
        if num_members is not APIHelper.SKIP:
            self.num_members = num_members
        if pending_shared is not APIHelper.SKIP:
            self.pending_shared = pending_shared
        if previous_names is not APIHelper.SKIP:
            self.previous_names = previous_names
        if priority is not APIHelper.SKIP:
            self.priority = priority
        self.purpose = purpose
        self.topic = topic
        if unlinked is not APIHelper.SKIP:
            self.unlinked = unlinked
        if unread_count is not APIHelper.SKIP:
            self.unread_count = unread_count
        if unread_count_display is not APIHelper.SKIP:
            self.unread_count_display = unread_count_display

        # Add additional model properties to the instance
        if additional_properties is None:
            additional_properties = {}
        self.additional_properties = additional_properties

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        created =\
            dictionary.get("created")\
            if dictionary.get("created")\
                else None
        creator =\
            dictionary.get("creator")\
            if dictionary.get("creator")\
                else None
        id =\
            dictionary.get("id")\
            if dictionary.get("id")\
                else None
        is_channel =\
            dictionary.get("is_channel")\
            if "is_channel" in dictionary.keys()\
                else None
        is_mpim =\
            dictionary.get("is_mpim")\
            if "is_mpim" in dictionary.keys()\
                else None
        is_org_shared =\
            dictionary.get("is_org_shared")\
            if "is_org_shared" in dictionary.keys()\
                else None
        is_private =\
            dictionary.get("is_private")\
            if "is_private" in dictionary.keys()\
                else None
        is_shared =\
            dictionary.get("is_shared")\
            if "is_shared" in dictionary.keys()\
                else None
        members =\
            dictionary.get("members")\
            if dictionary.get("members")\
                else None
        name =\
            dictionary.get("name")\
            if dictionary.get("name")\
                else None
        name_normalized =\
            dictionary.get("name_normalized")\
            if dictionary.get("name_normalized")\
                else None
        purpose =\
            Purpose.from_dictionary(
                dictionary.get("purpose"))\
                if dictionary.get("purpose") else None
        topic =\
            Topic.from_dictionary(
                dictionary.get("topic"))\
                if dictionary.get("topic") else None
        accepted_user =\
            dictionary.get("accepted_user")\
            if dictionary.get("accepted_user")\
                else APIHelper.SKIP
        is_archived =\
            dictionary.get("is_archived")\
            if "is_archived" in dictionary.keys()\
                else APIHelper.SKIP
        is_frozen =\
            dictionary.get("is_frozen")\
            if "is_frozen" in dictionary.keys()\
                else APIHelper.SKIP
        is_general =\
            dictionary.get("is_general")\
            if "is_general" in dictionary.keys()\
                else APIHelper.SKIP
        is_member =\
            dictionary.get("is_member")\
            if "is_member" in dictionary.keys()\
                else APIHelper.SKIP
        is_moved =\
            dictionary.get("is_moved")\
            if dictionary.get("is_moved")\
                else APIHelper.SKIP
        is_non_threadable =\
            dictionary.get("is_non_threadable")\
            if "is_non_threadable" in dictionary.keys()\
                else APIHelper.SKIP
        is_pending_ext_shared =\
            dictionary.get("is_pending_ext_shared")\
            if "is_pending_ext_shared" in dictionary.keys()\
                else APIHelper.SKIP
        is_read_only =\
            dictionary.get("is_read_only")\
            if "is_read_only" in dictionary.keys()\
                else APIHelper.SKIP
        is_thread_only =\
            dictionary.get("is_thread_only")\
            if "is_thread_only" in dictionary.keys()\
                else APIHelper.SKIP
        last_read =\
            dictionary.get("last_read")\
            if dictionary.get("last_read")\
                else APIHelper.SKIP
        latest =\
            dictionary.get("latest")\
            if dictionary.get("latest")\
                else APIHelper.SKIP
        num_members =\
            dictionary.get("num_members")\
            if dictionary.get("num_members")\
                else APIHelper.SKIP
        pending_shared =\
            dictionary.get("pending_shared")\
            if dictionary.get("pending_shared")\
                else APIHelper.SKIP
        previous_names =\
            dictionary.get("previous_names")\
            if dictionary.get("previous_names")\
                else APIHelper.SKIP
        priority =\
            dictionary.get("priority")\
            if dictionary.get("priority")\
                else APIHelper.SKIP
        unlinked =\
            dictionary.get("unlinked")\
            if dictionary.get("unlinked")\
                else APIHelper.SKIP
        unread_count =\
            dictionary.get("unread_count")\
            if dictionary.get("unread_count")\
                else APIHelper.SKIP
        unread_count_display =\
            dictionary.get("unread_count_display")\
            if dictionary.get("unread_count_display")\
                else APIHelper.SKIP

        additional_properties = APIHelper.get_additional_properties(
            dictionary={k: v for k, v in dictionary.items()
                        if k not in cls._names.values()},
            unboxing_function=lambda value: value)

        # Return an object of this model
        return cls(created,
                   creator,
                   id,
                   is_channel,
                   is_mpim,
                   is_org_shared,
                   is_private,
                   is_shared,
                   members,
                   name,
                   name_normalized,
                   purpose,
                   topic,
                   accepted_user,
                   is_archived,
                   is_frozen,
                   is_general,
                   is_member,
                   is_moved,
                   is_non_threadable,
                   is_pending_ext_shared,
                   is_read_only,
                   is_thread_only,
                   last_read,
                   latest,
                   num_members,
                   pending_shared,
                   previous_names,
                   priority,
                   unlinked,
                   unread_count,
                   unread_count_display,
                   additional_properties)

    def __repr__(self):
        """Return a unambiguous string representation."""
        _accepted_user=(
            self.accepted_user
            if hasattr(self, "accepted_user")
            else None
        )
        _created=self.created
        _creator=self.creator
        _id=self.id
        _is_archived=(
            self.is_archived
            if hasattr(self, "is_archived")
            else None
        )
        _is_channel=self.is_channel
        _is_frozen=(
            self.is_frozen
            if hasattr(self, "is_frozen")
            else None
        )
        _is_general=(
            self.is_general
            if hasattr(self, "is_general")
            else None
        )
        _is_member=(
            self.is_member
            if hasattr(self, "is_member")
            else None
        )
        _is_moved=(
            self.is_moved
            if hasattr(self, "is_moved")
            else None
        )
        _is_mpim=self.is_mpim
        _is_non_threadable=(
            self.is_non_threadable
            if hasattr(self, "is_non_threadable")
            else None
        )
        _is_org_shared=self.is_org_shared
        _is_pending_ext_shared=(
            self.is_pending_ext_shared
            if hasattr(self, "is_pending_ext_shared")
            else None
        )
        _is_private=self.is_private
        _is_read_only=(
            self.is_read_only
            if hasattr(self, "is_read_only")
            else None
        )
        _is_shared=self.is_shared
        _is_thread_only=(
            self.is_thread_only
            if hasattr(self, "is_thread_only")
            else None
        )
        _last_read=(
            self.last_read
            if hasattr(self, "last_read")
            else None
        )
        _latest=(
            self.latest
            if hasattr(self, "latest")
            else None
        )
        _members=self.members
        _name=self.name
        _name_normalized=self.name_normalized
        _num_members=(
            self.num_members
            if hasattr(self, "num_members")
            else None
        )
        _pending_shared=(
            self.pending_shared
            if hasattr(self, "pending_shared")
            else None
        )
        _previous_names=(
            self.previous_names
            if hasattr(self, "previous_names")
            else None
        )
        _priority=(
            self.priority
            if hasattr(self, "priority")
            else None
        )
        _purpose=self.purpose
        _topic=self.topic
        _unlinked=(
            self.unlinked
            if hasattr(self, "unlinked")
            else None
        )
        _unread_count=(
            self.unread_count
            if hasattr(self, "unread_count")
            else None
        )
        _unread_count_display=(
            self.unread_count_display
            if hasattr(self, "unread_count_display")
            else None
        )
        _additional_properties=self.additional_properties
        return (
            f"{self.__class__.__name__}("
            f"accepted_user={_accepted_user!r}, "
            f"created={_created!r}, "
            f"creator={_creator!r}, "
            f"id={_id!r}, "
            f"is_archived={_is_archived!r}, "
            f"is_channel={_is_channel!r}, "
            f"is_frozen={_is_frozen!r}, "
            f"is_general={_is_general!r}, "
            f"is_member={_is_member!r}, "
            f"is_moved={_is_moved!r}, "
            f"is_mpim={_is_mpim!r}, "
            f"is_non_threadable={_is_non_threadable!r}, "
            f"is_org_shared={_is_org_shared!r}, "
            f"is_pending_ext_shared={_is_pending_ext_shared!r}, "
            f"is_private={_is_private!r}, "
            f"is_read_only={_is_read_only!r}, "
            f"is_shared={_is_shared!r}, "
            f"is_thread_only={_is_thread_only!r}, "
            f"last_read={_last_read!r}, "
            f"latest={_latest!r}, "
            f"members={_members!r}, "
            f"name={_name!r}, "
            f"name_normalized={_name_normalized!r}, "
            f"num_members={_num_members!r}, "
            f"pending_shared={_pending_shared!r}, "
            f"previous_names={_previous_names!r}, "
            f"priority={_priority!r}, "
            f"purpose={_purpose!r}, "
            f"topic={_topic!r}, "
            f"unlinked={_unlinked!r}, "
            f"unread_count={_unread_count!r}, "
            f"unread_count_display={_unread_count_display!r}, "
            f"additional_properties={_additional_properties!r}, "
            f")"
        )

    def __str__(self):
        """Return a human-readable string representation."""
        _accepted_user=(
            self.accepted_user
            if hasattr(self, "accepted_user")
            else None
        )
        _created=self.created
        _creator=self.creator
        _id=self.id
        _is_archived=(
            self.is_archived
            if hasattr(self, "is_archived")
            else None
        )
        _is_channel=self.is_channel
        _is_frozen=(
            self.is_frozen
            if hasattr(self, "is_frozen")
            else None
        )
        _is_general=(
            self.is_general
            if hasattr(self, "is_general")
            else None
        )
        _is_member=(
            self.is_member
            if hasattr(self, "is_member")
            else None
        )
        _is_moved=(
            self.is_moved
            if hasattr(self, "is_moved")
            else None
        )
        _is_mpim=self.is_mpim
        _is_non_threadable=(
            self.is_non_threadable
            if hasattr(self, "is_non_threadable")
            else None
        )
        _is_org_shared=self.is_org_shared
        _is_pending_ext_shared=(
            self.is_pending_ext_shared
            if hasattr(self, "is_pending_ext_shared")
            else None
        )
        _is_private=self.is_private
        _is_read_only=(
            self.is_read_only
            if hasattr(self, "is_read_only")
            else None
        )
        _is_shared=self.is_shared
        _is_thread_only=(
            self.is_thread_only
            if hasattr(self, "is_thread_only")
            else None
        )
        _last_read=(
            self.last_read
            if hasattr(self, "last_read")
            else None
        )
        _latest=(
            self.latest
            if hasattr(self, "latest")
            else None
        )
        _members=self.members
        _name=self.name
        _name_normalized=self.name_normalized
        _num_members=(
            self.num_members
            if hasattr(self, "num_members")
            else None
        )
        _pending_shared=(
            self.pending_shared
            if hasattr(self, "pending_shared")
            else None
        )
        _previous_names=(
            self.previous_names
            if hasattr(self, "previous_names")
            else None
        )
        _priority=(
            self.priority
            if hasattr(self, "priority")
            else None
        )
        _purpose=self.purpose
        _topic=self.topic
        _unlinked=(
            self.unlinked
            if hasattr(self, "unlinked")
            else None
        )
        _unread_count=(
            self.unread_count
            if hasattr(self, "unread_count")
            else None
        )
        _unread_count_display=(
            self.unread_count_display
            if hasattr(self, "unread_count_display")
            else None
        )
        _additional_properties=self.additional_properties
        return (
            f"{self.__class__.__name__}("
            f"accepted_user={_accepted_user!s}, "
            f"created={_created!s}, "
            f"creator={_creator!s}, "
            f"id={_id!s}, "
            f"is_archived={_is_archived!s}, "
            f"is_channel={_is_channel!s}, "
            f"is_frozen={_is_frozen!s}, "
            f"is_general={_is_general!s}, "
            f"is_member={_is_member!s}, "
            f"is_moved={_is_moved!s}, "
            f"is_mpim={_is_mpim!s}, "
            f"is_non_threadable={_is_non_threadable!s}, "
            f"is_org_shared={_is_org_shared!s}, "
            f"is_pending_ext_shared={_is_pending_ext_shared!s}, "
            f"is_private={_is_private!s}, "
            f"is_read_only={_is_read_only!s}, "
            f"is_shared={_is_shared!s}, "
            f"is_thread_only={_is_thread_only!s}, "
            f"last_read={_last_read!s}, "
            f"latest={_latest!s}, "
            f"members={_members!s}, "
            f"name={_name!s}, "
            f"name_normalized={_name_normalized!s}, "
            f"num_members={_num_members!s}, "
            f"pending_shared={_pending_shared!s}, "
            f"previous_names={_previous_names!s}, "
            f"priority={_priority!s}, "
            f"purpose={_purpose!s}, "
            f"topic={_topic!s}, "
            f"unlinked={_unlinked!s}, "
            f"unread_count={_unread_count!s}, "
            f"unread_count_display={_unread_count_display!s}, "
            f"additional_properties={_additional_properties!s}, "
            f")"
        )
